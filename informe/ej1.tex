\section{Intro}
Además de la tabla de listas para cada entrada del mapa, decidimos agregar un contador de modificaciones, el cual tendrá dos utilidades en la clase, una es evitar que se ejecute addAndInc cuando se está ejecutando maximum y viceversa, y la otra es saber cuántas de estas se están ejecutando. Si el valor de este contador es positivo quiere decir que se están ejecutando ese número de addAndInc, y si es negativo se está ejecutando maximum. Para sincronizar correctamente los varios hilos de ejecución, utilizamos 2 mecanismos: por un lado, el contador está protegido por un mutex, para evitar que sea editado por 2 operaciones a la vez; y una variable de condición, que pone al thread en espera mientras la operación que desea realizar esté prohibida (por ejemplo, calcular maximum mientras se está agregando un elemento). También contamos con un arreglo de mutexes para bloquear cada lista individualmente mientras agregamos elementos.

\section{Ejercicio 1}
En el primer ejercicio se pide implementar el método push\_front de la lista atómica. Aquí tenemos crear un nuevo nodo y que este sea la nueva cabeza de la lista y que apunte a la vieja cabeza. El primer problema que nos cruzamos fue que primero realizabamos un exchange atómico de la cabeza antigua con el nuevo nodo y luego se lo apuntaba la la nueva cabeza. Este conjunto de operaciones no era atómico por lo que en ciertas situaciones si justo se intentaba de iterar la lista en el medio de estas dos operaciones habría una condición de carrera en la que la lista podría contener un solo elemento. Esto se solucionó aplicando la función atómica compare\_exchange\_weak a la vieja cabeza de la lista, asegurando que el nuevo nodo siempre apunte al último nodo agregado exitosamente.
